# 코딩테스트의 개요

## 코딩테스트의 종류

1. 알고리즘 코딩테스트
2. 과제형 코딩테스트

## 소스코드 관리

1. 자신만의 코드 템플릿을 미리 만드는게 유리
2. 대표적인 알고리즘(정렬, 최단 경로 등)의 기본형에 대하여 미리 코드 구현 필요
3. 라이브러리화하여 깃허브에서 미리 관리하는걸 추천

## 코딩테스트 준비하는 방법

1. 적절한 프로그래밍 언어를 선택하여 문법 공부
2. 알고리즘 유형별로 이론 및 핵심 문제를 10문제 이상 풀어보기

    - 대표적인 알고리즘 유형: 정렬, DFS/BFS, 구현, 완전탐색, 탐욕 알고리즘

3. 원하는 기업의 기출 풀기

## 시간복잡도

- 계산복잡도 이론에서 출발한 명칭 -> 값이 크게 증가하는 정도
- 시간복잡도는 알고리즘의 성능을 나타내는 척도
- 특정한 크기의 입력에 대한 알고리즘 수행 시간 분석
- 동일한 기능을 수행하는 알고리즘이 있는 경우, 일반적으로 복잡도가 낮을수록 우수
- 복잡도가 낮을수록 더 빠르다.

## 빅오표기법(Big-O Notation)

- 복잡도를 판단하는 방법 중에서, 가장 빠르게 증가하는 항 만을 고려하는 표기법.
- 함수의 상한을 나타낸다
- 예를 들어 연산 횟수가 $3N^3 + 5N^2 + 1,000,000$ 인 알고리즘이 있는 경우.
- N이 증가함에 따라서 $3N^3$을 제외한 다른 항의 영향력은 작아진다.
- Big-O 표기법에서는 차수가 가장 큰 항에서 계수를 제외하여 O($N^3$)으로 표현된다.

|시간 복잡도 | 의미 |
|------|------|
| O($1$) | 상수 시간(constant time) |
| O($logN$) | 로그 시간(log time) |
| O($N$) | 선형 시간(linear time) |
| O($NlogN$) | 로그 선형 시간(log-linear time) |
| O($N^2$) | 이차 시간(quadratic time) |
| O($N^3$) | 삼차 시간(cubic time) |
| O($2^N$) | 지수 시간(exponential time) |

위로 갈수록 좋고, 아래로 갈수록 나쁨(상수 시간이 가장 좋고, 지수 시간이 가장 안좋음)

- 로그시간의 경우에는 상수 시간에 상당할 정도로 성능이 좋다고 하기도 함.
- 관련된건 따로 찾아볼것.

## 각 시간 복잡도의 주요 사용 사례

  O(1) - 상수 시간

- 배열 인덱스 접근: arr[i]
- 해시 테이블 조회/삽입
- 스택/큐의 push/pop

  O(log N) - 로그 시간

- 이진 탐색 (Binary Search)
- 균형 이진 트리 탐색 (AVL, Red-Black Tree)
- 힙에서 삽입/삭제

  O(N) - 선형 시간

- 배열/리스트 순회
- 선형 탐색
- 단순 정렬되지 않은 배열에서 최댓값 찾기

  O(N log N) - 로그 선형 시간

- 효율적인 정렬 알고리즘 (merge sort, heap sort, quick sort 평균)
- 분할 정복 알고리즘

  O(N²) - 이차 시간

- 버블 정렬, 선택 정렬, 삽입 정렬
- 중첩 루프로 2차원 배열 처리
- 단순한 최근접 점 쌍 찾기

  O(N³) - 삼차 시간

- 행렬 곱셈 (일반적인 방법)
- 3중 중첩 루프
- Floyd-Warshall 최단 경로 알고리즘

  O(2^N) - 지수 시간

- 피보나치 수열 (단순 재귀)
- 부분집합 생성 (모든 조합)
- 외판원 문제 (brute force)

### 시간복잡도 예시 1

N개의 데이터의 합을 계산하는 프로그램 예제

```typescript
let array = [3,5,1,2,4]; // 5개의 데이터(N = 5)
let summary = 0; // 합계를 저장할 변수

// 모든 데이터를 하나씩 확인하며 합계를 계산
for (let i = 0; i < array.length; i++) {
    summary += array[i];
}

// 결과 출력
console.log(summary);
```

- 수행시간은 데이터의 개수 N개에 비례할 것임을 예측 가능
- 시간복잡도: O(N)

### 시간복잡도 예시 2

- 2중 반복 문법을 이용하는 프로그램 예제

```typescript
let array = [3,5,1,2,4]; // 5개의 데이터 (N = 5)

for (let i = 0; i < array.length; i++) {
    for (let j = 0; j < array.length; j++) {
        let temp = array[i] * array[j];
        console.log(temp);
    }
}
```

- 시간 복잡도: O($N^2$)
- [참고]: 모든 2중 반복 문법의 시간 복잡도가 O($N^2$)인 것은 아님.
- 소스코드가 내부적으로 다른 함수를 호출한다면 해당 함수에 대한 고려도 필요.

## 알고리즘 설계 팁

- 일반적인 CPU 기반의 개인 컴퓨터나 채점 목적의 컴퓨터를 고려해보자
- Javascript를 기준으로 1억번의 연산을 처리하기 위해 1 ~ 5 초 가량의 시간이 소요
- O($N^3$)의 알고리즘을 설계한 경우, N의 값이 5,000이 넘는다면 얼마나 걸릴까
- 코딩 테스트 문제에서 시간 제한은 통상 1 ~ 5초 가량.
- 문제에 명시되어 있지 않은 경우 대략 5초 정도라고 생각하고 문제를 푸는게 합리적

## 요구사항에 따라 적절한 알고리즘 설계하기

- 문제에서 가장 먼저 확인해야하는 내용은 시간제한(수행 시간 요구사항)
- 시간제한이 1초인 문제를 만났을 때, 일반적인 기준은 다음과 같다.
- N의 범위가 500인 경우: 시간복잡도가 O($N^3$)인 알고리즘을 설계하면 문제 해결 가능
- N의 범위가 2,000인 경우: 시간복잡도가 O($N^2$)인 알고리즘을 설계하면 문제 해결 가능
- N의 범위가 100,000인 경우: 시간복잡도가 O($NlogN$)인 알고리즘을 설계하면 문제 해결 가능
- N의 범위가 100,000인 경우: 시간복잡도가 O($N$)인 알고리즘을 설계하면 문제 해결 가능
